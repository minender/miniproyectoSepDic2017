* La entidad Categoria deberia ser débil de usuario.
* En infer.jsp se usa el resuelveManager dentro de un ciclo para ver si el teorema está resuelto o no, esto es ineficiente.
* Al darle a demostrar deben aparecer los teoremas (no los axiomas) clickeables para escojer cuál se va a demostrar.
* Si un teorema no admite un método de demostración, debe la opcion estar inhabilitada.
* Haz un orderby por número de teorema a la lista de teoremas en los queries que ordene 3.4, 3.4.a y 3.5 en ese orden.
* Los metateoremas se desbloquean cuando están demostrados todos los teoremas que usa como hipótesis.

Nuevos

* Cambiar el diseño de base de datos y hacer la migración.
* Hacer un plan de pruebas de flujo de navegación y automatizar las misma usando selenium.
* Hacer documentos del nuevo diseño de base de datos.
* Estamos trabajando con un sistema de abreviación en donde hace falta conocer cuál es el metodo de demostración usado.
* Sabiendo cuál es el método de demostración usado, se construye el árbol agregando los nodos correspondientes. ¿Se podrá inferir?
* Estudiando el árbol parcial de derivación, ¿se puede inferir el método? Si es así, no hace falta un campo en la tabla.
* Del árbol de derivación final ¿se puede deducir cuál es el método de demostración?
* Idear un sistema homogéneo de creación del árbol, basado en herencia, para todos los métodos de demostración.
* Arreglar inferencia de tipo para el teorema E.p == algo.
* Arreglar la automatic substitution cuando hay aplicaciones funcionales en los paratodo y existe.
* Utilizar el metateorema 2 del libro para partir de un lado cuando la igualdad = es de terminos.
* Arreglar el problema de que Node.js no puede procesar string en latex muy largos, por ejemplo el 
  teorema 9.9 por método directo en el primer paso aplicando 3.52 en el consecuente arroja este error de una.
* Arreglar el metateorema del True para teoremas que no contengan T (listo).
* Revisar el formulario de editar símbolo si carga los campos que están en la base de datos.
* Modificar que los datos inferibles del símbolo como infijo o rightassociativity se carguen en el formulario 
  de editar símbolo sin que estén guardados en la base de datos.
* Arreglar el orden en que se ordenan las variables libres y, por ende, el orden en que se abstraen las mismas para 
  que se puedan reconocer cuando un teorema ya existe salvo el nombre de las variables en todos los casos.
* Se lanza una excepción cuando se trata de editar un teorema siendo AdminTeoremas.
* Siempre que se hace click en el + de un teorema, se hace el ajax para cargar todos los metateoremas, pero es suficiente 
  que el ajax se haga sólo la primera vez (Listo)
* Los métodos de debilitamiento / fortalecimiento no están funcionando.
* En initStatementController, cuando generarHistorial aborta, al usuario le sale el mensaje de que el método de 
  demostracion no aplica a ese enunciado. Se deben separar los abort que dispara generarHistorial de los abort 
  de initStatementController.
* Si la ultima linea es c_{1} x_{113} (c_{1} x_{113} x_{113}) se unifica erróneamente con el teorema c_{1} x_{113} x_{113} 
  y sustitución [x_{113} := (c_{1} x_{113} x_{113})].
* Cambiar la direccion de la segunda subprueba de un AI cuando consta de una sola linea, actualizarla incluyendo MT

Ronald

* Revisar si la función "isReflexiveOperatorForUser" de ResuelveManager funciona para todos los casos o no.
* En los finish de Contra-recíproco y Contradicción falta ver si hay que hacer un setToPrint/setToPrinting.
* El método de transitividad debería no debería poder comenzar con una prueba cuyo operador sea =>, pero lo hace
  porque al buscar su operador, como la fórmula contieneT, devuelve algo que no es.
* Unificar la obtención del binaryOperatorId en la nueva función de ProofBoolean.
* Eliminar los parámetros simboloManager en las funciones de CrudOperationsImpl.

